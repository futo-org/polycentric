use sqlx::PgPool;
use uuid::Uuid;
use crate::models::Category;
use crate::utils::PaginationParams;

// Struct to hold the data needed to create a new category
// We exclude id and created_at as they are generated by the database
#[derive(serde::Deserialize)]
pub struct CreateCategoryData {
    pub name: String,
    pub description: String,
}

/// Inserts a new category into the database.
pub async fn create_category(
    pool: &PgPool,
    category_data: CreateCategoryData,
) -> Result<Category, sqlx::Error> {
    let new_category = sqlx::query_as!(
        Category, // The struct to map the result to
        r#"
        INSERT INTO categories (name, description)
        VALUES ($1, $2)
        RETURNING id, name, description, created_at, "order"
        "#,
        category_data.name,
        category_data.description
    )
    .fetch_one(pool) // Fetches exactly one record
    .await?;

    Ok(new_category)
}

/// Fetches a single category by its ID.
pub async fn get_category_by_id(pool: &PgPool, category_id: Uuid) -> Result<Option<Category>, sqlx::Error> {
    let category = sqlx::query_as!(
        Category,
        r#"
        SELECT id, name, description, created_at, "order"
        FROM categories
        WHERE id = $1
        "#,
        category_id
    )
    .fetch_optional(pool) // Fetches zero or one record
    .await?;

    Ok(category)
}

/// Fetches all categories from the database with pagination.
pub async fn get_all_categories(
    pool: &PgPool,
    pagination: &PaginationParams,
) -> Result<Vec<Category>, sqlx::Error> {
    let categories = sqlx::query_as!(
        Category,
        r#"
        SELECT id, name, description, created_at, "order"
        FROM categories
        ORDER BY "order" ASC
        LIMIT $1 OFFSET $2
        "#,
        pagination.limit() as i64, // Cast u64 to i64 for SQLx
        pagination.offset() as i64 // Cast u64 to i64 for SQLx
    )
    .fetch_all(pool)
    .await?;

    Ok(categories)
}

// Input data for updating a category
#[derive(serde::Deserialize)]
pub struct UpdateCategoryData {
    pub name: String,
    pub description: String,
}

/// Updates an existing category.
pub async fn update_category(
    pool: &PgPool,
    category_id: Uuid,
    update_data: UpdateCategoryData,
) -> Result<Option<Category>, sqlx::Error> {
    // Using Option<Category> to indicate if the category was found and updated
    let updated_category = sqlx::query_as!(
        Category,
        r#"
        UPDATE categories
        SET name = $1, description = $2
        WHERE id = $3
        RETURNING id, name, description, created_at, "order"
        "#,
        update_data.name,
        update_data.description,
        category_id
    )
    .fetch_optional(pool)
    .await?;

    Ok(updated_category)
}

/// Deletes a category by its ID.
/// Returns the number of rows affected (should be 0 or 1).
pub async fn delete_category(pool: &PgPool, category_id: Uuid) -> Result<u64, sqlx::Error> {
    let result = sqlx::query!(
        r#"
        DELETE FROM categories
        WHERE id = $1
        "#,
        category_id
    )
    .execute(pool)
    .await?;

    Ok(result.rows_affected())
}

/// Updates the order of multiple categories based on a provided list of IDs.
pub async fn update_category_order(pool: &PgPool, ordered_ids: &[Uuid]) -> Result<(), sqlx::Error> {
    let mut tx = pool.begin().await?;
    for (index, &category_id) in ordered_ids.iter().enumerate() {
        sqlx::query!(
            r#"UPDATE categories SET "order" = $1 WHERE id = $2"#,
            index as i32, // Cast index to i32 for INTEGER column
            category_id
        )
        .execute(&mut *tx) // Use deref coercion
        .await?;
    }
    tx.commit().await?;
    Ok(())
} 