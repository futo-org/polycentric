@0xcafebabedeadbeef; # TODO: Replace with a real ID generated by `capnp id`

struct PublicKey {
    keyType @0 :UInt64;
    key     @1 :Data;
}

struct Process {
    process @0 :Data;
}

struct Index {
    indexType    @0 :UInt64;
    logicalClock @1 :UInt64;
}

struct Indices {
    indices @0 :List(Index);
}

struct VectorClock {
    logicalClocks @0 :List(UInt64);
}

struct ModerationTag {
    name  @0 :Text;
    level @1 :UInt32;
}

struct SignedEvent {
    signature     @0 :Data;
    event         @1 :Data;
    moderationTags @2 :List(ModerationTag);
}

struct LWWElementSet {
    enum Operation {
        add    @0;
        remove @1;
    }
    operation        @0 :Operation;
    value            @1 :Data;
    unixMilliseconds @2 :UInt64;
}

struct LWWElement {
    value            @0 :Data;
    unixMilliseconds @1 :UInt64;
}

struct Server {
    server @0 :Text;
}

struct ImageManifest {
    mime      @0 :Text;
    width     @1 :UInt64;
    height    @2 :UInt64;
    byteCount @3 :UInt64;
    process   @4 :Process;
    sections  @5 :List(Range);
}

struct ImageBundle {
    imageManifests @0 :List(ImageManifest);
}

struct Event {
    system           @0  :PublicKey;
    process          @1  :Process;
    logicalClock     @2  :UInt64;
    contentType      @3  :UInt64;
    content          @4  :Data;
    vectorClock      @5  :VectorClock;
    indices          @6  :Indices;
    # Optional fields require careful consideration in Cap'n Proto.
    # Using union for explicit presence might be needed depending on usage.
    lwwElementSet    @7  :LWWElementSet;
    lwwElement       @8  :LWWElement;
    references       @9  :List(Reference);
    unixMilliseconds @10 :UInt64; # Was optional in proto3
}

struct SystemProcesses {
    processes @0 :List(Process);
}

struct Digest {
    digestType @0 :UInt64;
    digest     @1 :Data;
}

struct Pointer {
    system       @0 :PublicKey;
    process      @1 :Process;
    logicalClock @2 :UInt64;
    eventDigest  @3 :Digest;
}

struct Delete {
    process          @0 :Process;
    logicalClock     @1 :UInt64;
    indices          @2 :Indices;
    unixMilliseconds @3 :UInt64; # Was optional in proto3
    contentType      @4 :UInt64;
}

struct Events {
    events @0 :List(SignedEvent);
}

struct AggregationBucket {
    key   @0 :Data;
    value @1 :Int64;
}

struct PublicKeys {
    systems @0 :List(PublicKey);
}

struct Range {
    low  @0 :UInt64;
    high @1 :UInt64;
}

struct RangesForProcess {
    process @0 :Process;
    ranges  @1 :List(Range);
}

struct RangesForSystem {
    rangesForProcesses @0 :List(RangesForProcess);
}

struct PrivateKey {
    keyType @0 :UInt64;
    key     @1 :Data;
}

struct KeyPair {
    keyType   @0 :UInt64;
    privateKey @1 :Data;
    publicKey  @2 :Data;
}

struct ExportBundle {
    keyPair @0 :KeyPair;
    events  @1 :Events;
}

struct ResultEventsAndRelatedEventsAndCursor {
    resultEvents  @0 :Events;
    relatedEvents @1 :Events;
    cursor        @2 :Data; # Was optional in proto3
}

struct ResultTopStringReferences {
    buckets @0 :List(AggregationBucket);
}

struct Reference {
    referenceType @0 :UInt64;
    reference     @1 :Data;
}

struct Post {
    # Field @2 was reserved in proto
    content @0 :Text;        # Was optional in proto3
    image   @1 :ImageManifest; # Was optional in proto3
}

struct Claim {
    claimType  @0 :UInt64;
    claimFields @1 :List(ClaimFieldEntry);
}

struct ClaimFieldEntry {
    key   @0 :UInt64;
    value @1 :Text;
}

struct Vouch { } # Empty message translates to empty struct

struct StorageTypeProcessSecret {
    system  @0 :PrivateKey;
    process @1 :Process;
}

struct StorageTypeProcessState {
    logicalClock @0 :UInt64;
    ranges       @1 :List(Range);
    indices      @2 :Indices;
}

struct StorageTypeCRDTSetItem {
    contentType      @0 :UInt64;
    value            @1 :Data;
    unixMilliseconds @2 :UInt64;
    operation        @3 :LWWElementSet.Operation;
}

struct StorageTypeCRDTItem {
    contentType      @0 :UInt64;
    value            @1 :Data;
    unixMilliseconds @2 :UInt64;
}

struct StorageTypeSystemState {
    # Field @1 was reserved in proto
    processes   @0 :List(Process);
    crdtItems   @1 :List(StorageTypeCRDTItem);
}

struct StorageTypeEvent {
    event           @0 :SignedEvent; # Was optional in proto3
    mutationPointer @1 :Pointer;     # Was optional in proto3
}

struct RepeatedUInt64 {
    numbers @0 :List(UInt64);
}

# // start /query_references API

struct QueryReferencesRequest {
    reference                   @0 :Reference;
    cursor                      @1 :Data;                                # Was optional in proto3
    requestEvents               @2 :QueryReferencesRequestEvents;        # Was optional in proto3
    countLwwElementReferences  @3 :List(QueryReferencesRequestCountLWWElementReferences);
    countReferences             @4 :List(QueryReferencesRequestCountReferences);
    extraByteReferences         @5 :List(Data);
}

struct QueryReferencesRequestEvents {
    fromType                   @0 :UInt64; # Was optional in proto3
    countLwwElementReferences @1 :List(QueryReferencesRequestCountLWWElementReferences);
    countReferences            @2 :List(QueryReferencesRequestCountReferences);
}

struct QueryReferencesRequestCountLWWElementReferences {
    value     @0 :Data;
    fromType  @1 :UInt64; # Was optional in proto3
}

struct QueryReferencesRequestCountReferences {
    fromType @0 :UInt64; # Was optional in proto3
}

struct QueryReferencesResponseEventItem {
    event @0 :SignedEvent;
}

# ... Potentially more definitions from the rest of the proto file ...
# Add QueryReferencesResponse and subsequent definitions once proto file is fully visible. 