use sqlx::PgPool;
use uuid::Uuid;
use crate::models::Category;

// Struct to hold the data needed to create a new category
// We exclude id and created_at as they are generated by the database
#[derive(serde::Deserialize)]
pub struct CreateCategoryData {
    pub name: String,
    pub description: String,
}

/// Inserts a new category into the database.
pub async fn create_category(
    pool: &PgPool,
    category_data: CreateCategoryData,
) -> Result<Category, sqlx::Error> {
    let new_category = sqlx::query_as!(
        Category, // The struct to map the result to
        r#"
        INSERT INTO categories (name, description)
        VALUES ($1, $2)
        RETURNING id, name, description, created_at
        "#,
        category_data.name,
        category_data.description
    )
    .fetch_one(pool) // Fetches exactly one record
    .await?;

    Ok(new_category)
}

/// Fetches a single category by its ID.
pub async fn get_category_by_id(pool: &PgPool, category_id: Uuid) -> Result<Option<Category>, sqlx::Error> {
    let category = sqlx::query_as!(
        Category,
        r#"
        SELECT id, name, description, created_at
        FROM categories
        WHERE id = $1
        "#,
        category_id
    )
    .fetch_optional(pool) // Fetches zero or one record
    .await?;

    Ok(category)
}

/// Fetches all categories from the database.
pub async fn get_all_categories(pool: &PgPool) -> Result<Vec<Category>, sqlx::Error> {
    let categories = sqlx::query_as!(
        Category,
        r#"
        SELECT id, name, description, created_at
        FROM categories
        ORDER BY created_at DESC -- Or ORDER BY name, etc.
        "#
    )
    .fetch_all(pool) // Fetches all records
    .await?;

    Ok(categories)
}

// Input data for updating a category
#[derive(serde::Deserialize)]
pub struct UpdateCategoryData {
    pub name: String,
    pub description: String,
}

/// Updates an existing category.
pub async fn update_category(
    pool: &PgPool,
    category_id: Uuid,
    update_data: UpdateCategoryData,
) -> Result<Option<Category>, sqlx::Error> {
    // Using Option<Category> to indicate if the category was found and updated
    let updated_category = sqlx::query_as!(
        Category,
        r#"
        UPDATE categories
        SET name = $1, description = $2
        WHERE id = $3
        RETURNING id, name, description, created_at
        "#,
        update_data.name,
        update_data.description,
        category_id
    )
    .fetch_optional(pool)
    .await?;

    Ok(updated_category)
}

/// Deletes a category by its ID.
/// Returns the number of rows affected (should be 0 or 1).
pub async fn delete_category(pool: &PgPool, category_id: Uuid) -> Result<u64, sqlx::Error> {
    let result = sqlx::query!(
        r#"
        DELETE FROM categories
        WHERE id = $1
        "#,
        category_id
    )
    .execute(pool)
    .await?;

    Ok(result.rows_affected())
} 